/*
  +----------------------------------------------------------------------+
  | PHP Version 5                                                        |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997-2012 The PHP Group                                |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.01 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_01.txt                                  |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author: Chung Leong <cleong@cal.berkeley.edu>                        |
  +----------------------------------------------------------------------+
*/

/* $Id$ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "qb.h"
#include "qb_interpreter_msvc.h"

void ZEND_FASTCALL qb_run(qb_interpreter_context *__restrict cxt) {
	
	if(cxt) {
		register void *__restrict op_handler;
		register int8_t *__restrict instruction_pointer;
		int8_t *__restrict segments[MAX_SEGMENT_COUNT];
		int8_t *__restrict segment0;
		int32_t segment_expandable[MAX_SEGMENT_COUNT];
		uint32_t segment_element_counts[MAX_SEGMENT_COUNT];
		uint32_t selector, index, index_index, size_index;
		uint32_t string_length;
		uint32_t vector_count, matrix1_count, matrix2_count, mmult_res_count;
		uint32_t op1_start_index, op2_start_index, op3_start_index, op4_start_index, op5_start_index;
		uint32_t op1_count, op2_count, op3_count, op4_count, op5_count;
		uint32_t res_start_index, res_count, res_count_before;
		uint32_t windows_timeout_check_counter = 0;
		volatile zend_bool *windows_timed_out_pointer = cxt->windows_timed_out_pointer;
		USE_TSRM
		
		{
			uint32_t i;
			instruction_pointer = cxt->function->instructions;
			op_handler = *((void **) instruction_pointer);
			instruction_pointer += sizeof(void *);
			// copy values from cxt onto the stack so they can be accessed without two second deferences
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segments[i] = segment->memory;
				segment_element_counts[i] = *segment->array_size_pointer;
				segment_expandable[i] = (segment->flags & QB_SEGMENT_EXPANDABLE);
				// set the pointers in the segment structure to local variables here so we can update
				// them as well when we expand the segment
				segment->stack_ref_memory = &segments[i];
				segment->stack_ref_element_count = &segment_element_counts[i];
			}
			// store pointer to segment 0 in a separate variable to enable better optimization
			// since segment 0 and 1 will never be enlarged, we don't have to worry about it changing
			segment0 = segments[0];
		}
		
		do {
			switch((int) op_handler) {
				case QB_NOP:
				op_handler = ((qb_instruction_0 *) instruction_pointer)->next_handler;
				{
					
				}
				instruction_pointer += sizeof(qb_instruction_0);
				break;
				
				case QB_JMP:
				op_handler = ((qb_instruction_jump_0 *) instruction_pointer)->next_handler;
				{
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
				}
				instruction_pointer = ((qb_instruction_jump_0 *) instruction_pointer)->instruction_pointer;
				break;
				
				case QB_RET:
				{
				}
				goto label_exit;
				
				case QB_EXIT_I32:
				{
					int32_t *__restrict op1_ptr;
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					EG(exit_status) = op1;
					zend_bailout();
				}
				
				case QB_FCALL_VAR:
				op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
					uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
					uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
					uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
					uint32_t i;
					zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
					qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
					cxt->argument_address = &cxt->value_address;
					cxt->value_address.segment_selector = QB_SELECTOR_VARIABLE;
					for(i = 0, op = operands; i < argument_count; i++) {
						op += qb_decode_fcall_variable_operand(cxt, segments, op);
						qb_copy_argument(cxt, i);
					}
					qb_execute_function_call(cxt);
					for(i = 0, op = operands; i < argument_count + 1; i++) {
						op += qb_decode_fcall_variable_operand(cxt, segments, op);
						qb_resync_argument(cxt, i);
					}
					qb_finalize_function_call(cxt);
					if(cxt->exception_encountered) {
						goto label_exit;
					}
					instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_FCALL_MIX:
				op_handler = ((qb_instruction_fcall *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_fcall *) instruction_pointer)->line_number
					uint32_t symbol_index = ((qb_instruction_fcall *) instruction_pointer)->symbol_index;
					uint32_t argument_count = ((qb_instruction_fcall *) instruction_pointer)->argument_count;
					uint32_t *operands = ((qb_instruction_fcall *) instruction_pointer)->operands, *op;
					uint32_t i;
					zend_function *function = cxt->function->external_symbols[symbol_index]->pointer;
					qb_initialize_function_call(cxt, function, argument_count, PHP_LINE_NUMBER);
					for(i = 0, op = operands; i < argument_count; i++) {
						op += qb_decode_fcall_mix_operand(cxt, segments, op);
						qb_copy_argument(cxt, i);
					}
					qb_execute_function_call(cxt);
					for(i = 0, op = operands; i < argument_count + 1; i++) {
						op += qb_decode_fcall_mix_operand(cxt, segments, op);
						qb_resync_argument(cxt, i);
					}
					qb_finalize_function_call(cxt);
					if(cxt->exception_encountered) {
						goto label_exit;
					}
					instruction_pointer += sizeof(((qb_instruction_fcall *) instruction_pointer)->next_handler) + ((qb_instruction_fcall *) instruction_pointer)->operand_size;
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_INIT:
				op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					if(cxt->storage->flags & QB_STORAGE_STATIC_INITIALIZED) {
						condition = 1;
					} else {
						condition = 0;
						cxt->storage->flags |= QB_STORAGE_STATIC_INITIALIZED;
					}
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_0 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_0 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_T_I32_VAR:
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					index = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_T_I32_ELV:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					selector = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_F_I32_VAR:
				op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					index = ((qb_instruction_branch_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = !op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_F_I32_ELV:
				op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_1_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					selector = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = !op1;
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_1_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_1_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_EQ_I32_I32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I32_I32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I32_I32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I32_I32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S32_S32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S32_S32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_divide_S32(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_divide_S32(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_S32_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_S32_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_S32_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_NEG_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int32_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_I32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int32_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_I32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S32_S32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S32_S32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S32_S32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S32_S32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S32_S32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S32_S32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I32_I32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I32_I32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S32_S32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S32_S32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NOT_SET_I32_I32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_vector_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ANY_I32_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_any_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ANY_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_any_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ALL_I32_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_all_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ALL_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_all_I32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_AND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_and_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_or_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_xor_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_not_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 && op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_OR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = op1 || op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_XOR_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !op1 != !op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NOT_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ISSET_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int32_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_I32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_I32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_I32_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I32_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I32_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I32_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I32_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S32_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S32_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_I32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S32_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S32_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_S32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_random_S32(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_random_S32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S32_S32_S32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_random_mt_S32(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S32_S32_S32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_random_mt_S32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S32_S32_S32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int32_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					qb_do_print_variable_S32(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_print_variable_S32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_S32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_S32_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_S32(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_S32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_S32_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_S32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PACK_LE_I32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint32_t *) res_ptr) = SWAP_LE_I32(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint32_t *) res_ptr) = SWAP_LE_I32(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint32_t *) res_ptr) = SWAP_BE_I32(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint32_t *) res_ptr) = SWAP_BE_I32(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int32_t), qb_compare_ascending_S32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int32_t), qb_compare_descending_S32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_min_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_max_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_product_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S32_S32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_sum_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_array_min_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_array_max_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_array_product_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					qb_do_array_sum_S32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I32_I32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_I32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_I32_I32_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_I32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_I32_I32_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_I32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_I32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_I32(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_I32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_I32(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U32_U32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U32_U32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_divide_U32(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_divide_U32(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_U32_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_U32_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_U32_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LT_U32_U32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U32_U32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U32_U32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U32_U32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U32_U32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U32_U32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U32_U32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U32_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U32_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U32_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_U32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_random_U32(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_random_U32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U32_U32_U32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_random_mt_U32(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U32_U32_U32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_random_mt_U32(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U32_U32_U32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_UTF8_DEC_U08_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_utf8_codepoint_count(op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_utf8decode_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UTF8_ENC_U32_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_utf8_encoded_length_U32(op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_utf8encode_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint32_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_print_variable_U32(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_print_variable_U32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_U32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_U32_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_U32(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_U32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_U32_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_U32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SORT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint32_t), qb_compare_ascending_U32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint32_t), qb_compare_descending_U32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_array_min_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_array_max_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_array_product_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U32_U32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					qb_do_array_sum_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_array_min_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_array_max_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_array_product_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					qb_do_array_sum_U32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I08_I08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I08_I08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I08_I08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I08_I08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S08_S08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S08_S08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_divide_S08(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_divide_S08(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int8_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_I08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int8_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_I08(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S08_S08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S08_S08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S08_S08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S08_S08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S08_S08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S08_S08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S08(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I08_I08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I08_I08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S08_S08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S08_S08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_and_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_or_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I08_I08_I08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I08_I08_I08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I08_I08_I08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_xor_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I08_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I08_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I08_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_not_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int8_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_I08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_I08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_S08_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S08_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S08_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S08_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S08_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S08_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S08_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I08_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_I08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I08_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S08_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S08_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_S08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_random_S08(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_random_S08(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S08_S08_S08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_random_mt_S08(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S08_S08_S08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_random_mt_S08(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S08_S08_S08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int8_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					qb_do_print_variable_S08(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_print_variable_S08(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_S08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_S08_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int8_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S08(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S08(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S08(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S08(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S08_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_S08(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_S08(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_S08_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_S08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SORT_S08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int8_t), qb_compare_ascending_S08);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int8_t), qb_compare_descending_S08);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_array_min_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_array_max_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_array_product_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S08_S08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					qb_do_array_sum_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_array_min_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_array_max_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_array_product_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S08_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					qb_do_array_sum_S08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I08(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I08(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I08(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I08(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I08_I08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_I08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_I08_I08_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_I08(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_I08_I08_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					int8_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_I08(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_I08_U32_I08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_I08(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_I08_U32_I08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_I08(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U08_U08_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U08_U08_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_divide_U08(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_divide_U08(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U08_U08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U08_U08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U08_U08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U08(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U08_U08_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U08_U08_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U08_U08_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U08(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U08_U08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U08_U08_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U08_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U08_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U08_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U08_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U08_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U08_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U08_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_U08(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_random_U08(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_random_U08(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U08_U08_U08_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint8_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_random_mt_U08(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U08_U08_U08_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_random_mt_U08(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U08_U08_U08_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint8_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_STR_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					php_write(op1_ptr, op1_count TSRMLS_CC);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_CAT_STR_U08_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					memcpy(res_ptr + res_count_before, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U08_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint8_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_print_variable_U08(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U08_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_print_variable_U08(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U08_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_U08(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_U08_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint8_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U08(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U08(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U08(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U08(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U08_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_U08(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_U08(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_U08_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_U08(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SORT_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint8_t), qb_compare_ascending_U08);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U08:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint8_t), qb_compare_descending_U08);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_array_min_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_array_max_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_array_product_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U08_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					qb_do_array_sum_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_array_min_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_array_max_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_array_product_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U08_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					qb_do_array_sum_U08(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I16_I16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I16_I16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I16_I16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I16_I16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S16_S16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S16_S16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_divide_S16(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_divide_S16(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int16_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_I16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int16_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_I16(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S16_S16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S16_S16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S16_S16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S16_S16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S16_S16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S16_S16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S16(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I16_I16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I16_I16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S16_S16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S16_S16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_and_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_or_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I16_I16_I16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I16_I16_I16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I16_I16_I16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_xor_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I16_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I16_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I16_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_not_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int16_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_I16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_I16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_S16_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S16_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I16_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I16_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I16_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S16_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S16_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S16_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S16_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S16_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I16_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_I16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I16_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S16_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) abs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) abs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S16_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_S16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_random_S16(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_random_S16(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S16_S16_S16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_random_mt_S16(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S16_S16_S16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_random_mt_S16(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S16_S16_S16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int16_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					qb_do_print_variable_S16(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_print_variable_S16(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_S16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_S16_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S16(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S16(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S16(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S16(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S16_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_S16(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_S16(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_S16_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_S16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PACK_LE_I16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(2 > res_count) {
						res_count = 2;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint16_t *) res_ptr) = SWAP_LE_I16(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(2 > res_count) {
						res_count = 2;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint16_t *) res_ptr) = SWAP_LE_I16(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int16_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(2 > res_count) {
						res_count = 2;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint16_t *) res_ptr) = SWAP_BE_I16(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(2 > res_count) {
						res_count = 2;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint16_t *) res_ptr) = SWAP_BE_I16(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					*((uint16_t *) &res) = SWAP_LE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					*((uint16_t *) &res) = SWAP_LE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					*((uint16_t *) &res) = SWAP_BE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					*((uint16_t *) &res) = SWAP_BE_I16(*((uint16_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int16_t), qb_compare_ascending_S16);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int16_t), qb_compare_descending_S16);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_array_min_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_array_max_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_array_product_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S16_S16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					qb_do_array_sum_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_array_min_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_array_max_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_array_product_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S16_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					qb_do_array_sum_S16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I16(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I16(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I16(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I16(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I16_I16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_I16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_I16_I16_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_I16(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_I16_I16_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					int16_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_I16(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_I16_U32_I16:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_I16(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_I16_U32_I16:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_I16(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U16_U16_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U16_U16_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_divide_U16(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_divide_U16(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U16_U16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U16_U16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U16_U16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U16(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U16_U16_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U16_U16_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U16_U16_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U16(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U16_U16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U16_U16_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U16_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U16_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U16_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U16_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U16_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U16_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U16_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_U16(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_random_U16(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_random_U16(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U16_U16_U16_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint16_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_random_mt_U16(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U16_U16_U16_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_random_mt_U16(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U16_U16_U16_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict op2_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint16_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_UTF8_DEC_U08_U16:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_utf8_codepoint_count(op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_utf8decode_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UTF8_ENC_U16_U08:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_utf8_encoded_length_U16(op1_ptr, op1_count);
					if(string_length > res_count) {
						res_count = string_length;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_utf8encode_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_U16_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint16_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_print_variable_U16(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U16_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_print_variable_U16(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U16_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_U16(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_U16_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint16_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U16(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U16(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U16(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U16(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U16_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_U16(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_U16(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_U16_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_U16(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SORT_U16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint16_t), qb_compare_ascending_U16);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U16:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint16_t), qb_compare_descending_U16);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_array_min_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_array_max_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_array_product_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U16_U16_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					qb_do_array_sum_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_array_min_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_array_max_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_array_product_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U16_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint16_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint16_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					qb_do_array_sum_U16(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_I64_I64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_I64_I64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_I64_I64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_I64_I64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_S64_S64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_S64_S64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_divide_S64(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_divide_S64(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_S64_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict op3_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_S64_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict op3_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_S64_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict op3_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_NEG_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int64_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_I64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_I64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_I64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int64_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_I64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_I64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_I64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S64_S64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_S64_S64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_S64_S64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S64_S64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_S64_S64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_S64_S64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_S64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_I64_I64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_I64_I64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_S64_S64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_S64_S64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 & op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_AND_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 & op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_AND_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_and_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 | op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_OR_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 | op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_OR_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_or_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I64_I64_I64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 ^ op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_BW_XOR_I64_I64_I64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 ^ op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_XOR_I64_I64_I64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_xor_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_BW_NOT_I64_I64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = ~op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BW_NOT_I64_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = ~op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BW_NOT_I64_I64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_bitwise_not_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SHL_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_I64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((int64_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_I64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_I64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_I64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_I64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I64_I32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I64_I08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_I64_I16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_I64_I16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_I64_I16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_S64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_S64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_S64_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_I64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_I64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_I64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S64_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) llabs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) llabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_S64_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_S64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_random_S64(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_random_S64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S64_S64_S64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_random_mt_S64(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_S64_S64_S64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_random_mt_S64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_S64_S64_S64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_S64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					int64_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					qb_do_print_variable_S64(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_S64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_print_variable_S64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_S64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_S64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_S64_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_S64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_S64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_S64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_S64(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_S64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_S64_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_S64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PACK_LE_I64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint64_t *) res_ptr) = SWAP_LE_I64(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_I64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint64_t *) res_ptr) = SWAP_LE_I64(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((int64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint64_t *) res_ptr) = SWAP_BE_I64(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_I64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					*((uint64_t *) res_ptr) = SWAP_BE_I64(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_I64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_S64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int64_t), qb_compare_ascending_S64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_S64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(int64_t), qb_compare_descending_S64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_array_min_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_array_max_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_array_product_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S64_S64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					qb_do_array_sum_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_array_min_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_array_max_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_array_product_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_S64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					qb_do_array_sum_S64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_I64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((int64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_I64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_I64_I64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_I64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_I64_I64_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_I64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_I64_I64_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					int64_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_I64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_I64_U32_I64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_I64(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_I64_U32_I64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					int64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((int64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_I64(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_IF_LT_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_U64_U64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_U64_U64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_MUL_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_divide_U64(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_divide_U64(cxt, op1_ptr, op2_ptr, res_ptr, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = op1 % op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = op1 % op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_U64_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict op3_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_U64_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict op3_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_U64_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict op3_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((uint64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LT_U64_U64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_U64_U64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_U64_U64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U64_U64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_U64_U64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_U64_U64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_U64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_U64_U64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_U64_U64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = op1 << op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHL_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = op1 << op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHL_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_left_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = op1 >> op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SHR_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = op1 >> op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SHR_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_shift_right_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_U64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_U64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_U64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_U64_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_U64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_random_U64(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_RAND_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_random_U64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_RAND_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_random_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U64_U64_U64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((uint64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_random_mt_U64(cxt, op1_ptr, op2_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MT_RAND_U64_U64_U64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_random_mt_U64(cxt, op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MT_RAND_U64_U64_U64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict op2_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_random_mt_multiple_times_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PRN_U64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					uint64_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_print_variable_U64(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_U64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_print_variable_U64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_U64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_U64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_U64_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_U64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_U64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_U64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_U64(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_U64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_U64_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_U64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SORT_U64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint64_t), qb_compare_ascending_U64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_U64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(uint64_t), qb_compare_descending_U64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_array_min_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_array_max_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_array_product_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U64_U64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					qb_do_array_sum_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_array_min_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_array_max_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_array_product_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_U64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					qb_do_array_sum_U64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F32_F32_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_F32_F32_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = fmodf(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = fmodf(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) (op1 - op2 * floor(op1 / op2));
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_floored_division_modulo_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float32_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float32_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F32(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_F32_F32_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((float32_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_F32_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = (uint32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = (uint8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_U08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = (uint16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = (uint64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_U64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_U64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F32_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F32_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F32_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) fabsf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) fabsf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) sinf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) sinf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = asinf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = asinf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_asin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = cosf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = cosf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) acosf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOS_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) acosf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_acos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = tanf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TAN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = tanf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_tan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = atanf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATAN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = atanf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_atan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN2_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = atan2f(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ATAN2_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = atan2f(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_atan2_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SINH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = sinhf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SINH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = sinhf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = asinhf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASINH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = asinhf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_asinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = coshf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COSH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = coshf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = acoshf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOSH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = acoshf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_acosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = tanhf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TANH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = tanhf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_tanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = atanhf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATANH_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = atanhf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_atanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = ceilf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_CEIL_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = ceilf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_ceil_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) floorf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FLOOR_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) floorf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_floor_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) _php_math_round(op1, op2, op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F32_I32_I32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_round_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LOG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = logf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = logf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_log_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = log1pf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG1P_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = log1pf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_log1p_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = log2f(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG2_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = log2f(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_log2_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = log10f(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG10_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = log10f(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_log10_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = expf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = expf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_exp_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = expm1f(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXPM1_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = expm1f(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_exp_m1_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = exp2f(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP2_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = exp2f(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_exp2_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_POW_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = powf(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_POW_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = powf(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_pow_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SQRT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = sqrtf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SQRT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = sqrtf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sqrt_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_HYPOT_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) hypotf(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_HYPOT_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) hypotf(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_hypot_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LCG_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_lcg_F32(cxt, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_LCG_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_lcg_F32(cxt, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_lcg_multiple_times_F32(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_FIN_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = zend_finite(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FIN_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_finite_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (zend_isinf(op1) != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_INF_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_infinite_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F32_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = zend_isnan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NAN_F32_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F32_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_nan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RSQRT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = qb_fast_rsqrtf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RSQRT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = qb_fast_rsqrtf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RSQRT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_rsqrt_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_clamp_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_clamp_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_clamp_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_FRACT_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 - floorf(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FRACT_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 - floorf(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_fract_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIX_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 * (1 - op3) + op2 * op3;
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MIX_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 * (1 - op3) + op2 * op3;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_mix_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SIGN_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_sign_F32(op1_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIGN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_sign_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sign_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_STEP_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = ((op2 < op1) ? 0.0f : 1.0f);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_STEP_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = ((op2 < op1) ? 0.0f : 1.0f);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_step_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_smooth_step_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_smooth_step_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_smooth_step_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_RAD2DEG_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 * ((float32_t) (180 / M_PI));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RAD2DEG_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 * ((float32_t) (180 / M_PI));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_radian_to_degree_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F32_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = op1 * ((float32_t) (M_PI / 180.0));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_DEG2RAD_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = op1 * ((float32_t) (M_PI / 180.0));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_degree_to_radian_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_F32_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float32_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					qb_do_print_variable_F32(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_F32_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_print_variable_F32(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_F32(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_F32_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_F32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_F32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_F32(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_F32(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F32_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_F32(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_F32(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_F32_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_F32(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PACK_LE_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F32(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F32(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F32_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F32(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F32_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F32(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					*((uint32_t *) &res) = SWAP_LE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					*((uint32_t *) &res) = SWAP_BE_I32(*((uint32_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(float32_t), qb_compare_ascending_F32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(float32_t), qb_compare_descending_F32);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_array_min_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_array_max_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_array_product_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_array_sum_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_array_min_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_array_max_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_array_product_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_array_sum_F32(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_F32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_F32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_F32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_F32(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F32_F32_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_F32_F32_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_F32_F32_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_F32_U32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_F32(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_F32_U32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_F32(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F32_U32_U32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 4 > res_count) {
						res_count = op4_count * 4;
					}
					if(op5_count * 4 > res_count) {
						res_count = op5_count * 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F32_U32_U32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 3 > res_count) {
						res_count = op4_count * 3;
					}
					if(op5_count * 3 > res_count) {
						res_count = op5_count * 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F32_U32_U32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 4 > res_count) {
						res_count = op4_count * 4;
					}
					if(op5_count * 4 > res_count) {
						res_count = op5_count * 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_F32(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F32_U32_U32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float32_t *__restrict op4_ptr;
					float32_t *__restrict op5_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float32_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float32_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 3 > res_count) {
						res_count = op4_count * 3;
					}
					if(op5_count * 3 > res_count) {
						res_count = op5_count * 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_BLEND_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_alpha_blend_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PREMULT_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_apply_premultiplication_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPREMULT_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_remove_premultiplication_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					matrix2_count = op2_count / 16;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 16;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 16;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_determinant_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_determinant_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]) + (op1_ptr[3] * op2_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]) + (op1_ptr[3] * op2_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_length_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_length_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_length_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_distance_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_distance_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_4x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FORE_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_4X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_4x_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_4X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_4x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
					res_ptr[2] = op1_ptr[2];
					res_ptr[3] = op1_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
					res_ptr[2] = op1_ptr[2] + op2_ptr[2];
					res_ptr[3] = op1_ptr[3] + op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_add_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
					res_ptr[2] = op1_ptr[2] - op2_ptr[2];
					res_ptr[3] = op1_ptr[3] - op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
					res_ptr[2] = op1_ptr[2] * op2_ptr[2];
					res_ptr[3] = op1_ptr[3] * op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
					res_ptr[2] = op1_ptr[2] / op2_ptr[2];
					res_ptr[3] = op1_ptr[3] / op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_4X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
					res_ptr[2] = fmodf(op1_ptr[2], op2_ptr[2]);
					res_ptr[3] = fmodf(op1_ptr[3], op2_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_4X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_4X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
					res_ptr[2] = - op1_ptr[2];
					res_ptr[3] = - op1_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_4X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_4x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_4X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
					++res_ptr[2];
					++res_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_4X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_4x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_4X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
					--res_ptr[2];
					--res_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_4X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_4x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_4X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
					res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
					res_ptr[3] = op1_ptr[3] + (op2_ptr[3] * op3_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_4X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_4x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					matrix2_count = op2_count / 9;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 9;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					matrix2_count = op2_count / 3;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 3;
					matrix2_count = op2_count / 9;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_3XP_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3XP_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3XP_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_3x_padded_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_determinant_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_determinant_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]) + (op1_ptr[2] * op2_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_length_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_length_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_length_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_distance_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_distance_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_3x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CROSS_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_3X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_3x_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_3X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_3x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
					res_ptr[2] = op1_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
					res_ptr[2] = op1_ptr[2] + op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_add_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
					res_ptr[2] = op1_ptr[2] - op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
					res_ptr[2] = op1_ptr[2] * op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
					res_ptr[2] = op1_ptr[2] / op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_3X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
					res_ptr[2] = fmodf(op1_ptr[2], op2_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_3X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_3X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
					res_ptr[2] = - op1_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_3X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_3x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_3X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
					++res_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_3X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_3x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_3X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
					--res_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_3X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_3x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_3X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
					res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_3X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_3x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 2;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 2;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1_ptr[0 * 2 + 0] * op1_ptr[1 * 2 + 1]) - (op1_ptr[0 * 2 + 1] * op1_ptr[1 * 2 + 0]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1_ptr[0 * 2 + 0] * op1_ptr[1 * 2 + 1]) - (op1_ptr[0 * 2 + 1] * op1_ptr[1 * 2 + 0]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (op1_ptr[0] * op2_ptr[0]) + (op1_ptr[1] * op2_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_length_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_length_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_length_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_distance_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_distance_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_2x_F32(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CROSS_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_2X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_2x_F32(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_2X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_2x_F32(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_add_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_2X_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmodf(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmodf(op1_ptr[1], op2_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_2X_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_2X_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_2X_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_2x_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_2X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_2X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_2x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_2X_F32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_2X_F32_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_2x_multiple_times_F32(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_2X_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_2X_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_2x_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_F32_F32_F32:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MM_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * MATRIX2_COLS);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MV_F32_F32_F32:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MV_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * 1);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * 1);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_VM_F32_F32_F32:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_VM_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (1 * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (1 * MATRIX2_COLS);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MTRAN_F32_F32:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MTRAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MINV_F32_F32:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MINV_F32_F32_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F32_F32_VAR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_determinant_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F32_F32_ELV:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_determinant_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F32_F32_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_dot_product_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_dot_product_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DOT_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_LEN_F32_F32_VAR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_length_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_LEN_F32_F32_ELV:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_length_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_LEN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_length_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_VAR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float32_t *) segment0) + index;
					
					qb_do_distance_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_ELV:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					qb_do_distance_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DIS_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_NORM_F32_F32:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_F32(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_NORM_F32_F32_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_multiple_times_F32(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_FORE_F32_F32_F32:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_FORE_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFL_F32_F32_F32:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_F32(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFL_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFR_F32_F32_F32_F32:
				op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_F32(op1_ptr, op2_ptr, op3_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
				break;
				
				case QB_REFR_F32_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict op3_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float32_t *) segment0) + index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
				break;
				
				case QB_CABS_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = (float32_t) sqrt(op1_ptr[0] * op1_ptr[0] + op1_ptr[1] * op1_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CABS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_abs_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CARG_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = (float32_t) atan2(op1_ptr[1], op1_ptr[0]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CARG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_argument_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CMUL_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_multiply_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CMUL_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_multiply_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CDIV_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_divide_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CDIV_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_divide_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CEXP_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_exp_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEXP_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_exp_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLOG_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_log_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLOG_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_log_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSQRT_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_square_root_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSQRT_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_square_root_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CPOW_F32_F32_F32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_pow_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CPOW_F32_F32_F32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict op2_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_pow_multiple_times_F32(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CSIN_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sin_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSIN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sin_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOS_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cos_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOS_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cos_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTAN_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tan_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTAN_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tan_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSINH_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sinh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSINH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sinh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOSH_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cosh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOSH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cosh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTANH_F32_F32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tanh_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTANH_F32_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float32_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float32_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tanh_multiple_times_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_IF_EQ_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_EQ_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 == op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_NE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_NE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 != op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LT_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LT_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 < op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GT_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GT_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 > op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_LE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_LE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 <= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_IF_GE_F64_F64_VAR:
				op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler1;
				{
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_branch_2 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2 *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2 *) instruction_pointer)->instruction_pointer2;
					}
				}
				break;
				
				case QB_IF_GE_F64_F64_ELV:
				op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler1;
				{
#define PHP_LINE_NUMBER	((qb_instruction_branch_2_lineno *) instruction_pointer)->line_number
					int32_t condition;
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_branch_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
#ifdef ZEND_WIN32
					if(windows_timeout_check_counter == 4096) {
						if(*windows_timed_out_pointer) {
							zend_timeout(1);
							goto label_exit;
						}
					} else {
						windows_timeout_check_counter++;
					}
#endif
					condition = (op1 >= op2);
					if(condition) {
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer1;
					} else {
						op_handler = ((qb_instruction_branch_2_lineno *) instruction_pointer)->next_handler2;
						instruction_pointer = ((qb_instruction_branch_2_lineno *) instruction_pointer)->instruction_pointer2;
					}
#undef PHP_LINE_NUMBER
				}
				break;
				
				case QB_ADD_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 + op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ADD_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 + op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_add_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 - op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_SUB_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 - op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 * op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MUL_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 * op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 / op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_DIV_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 / op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = fmod(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = fmod(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAC_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 + (op2 * op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MAC_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 + (op2 * op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) (op1 - op2 * floor(op1 / op2));
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) (op1 - op2 * floor(op1 / op2));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_FLR_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_floored_division_modulo_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = - op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NEG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = - op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float64_t *) segment0) + index;
					
					++res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_INC_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					++res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float64_t *) segment0) + index;
					
					--res;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_DEC_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					--res;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_EQ_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_EQ_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 == op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) == 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_NE_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 != op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LT_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 < op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) == -1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_LE_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1 <= op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (qb_compare_array_F64(op1_ptr, op1_count, op2_ptr, op2_count) != 1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_EQ_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NE_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_not_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LT_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LE_SET_F64_F64_I32:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_less_than_or_equal_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ISSET_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index >= segment_element_counts[selector]) {
						op1_ptr = NULL;
					} else {
						op1_ptr = ((float64_t *) segments[selector]) + index;
					}
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (op1_ptr) && (op1 != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNSET_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = 0;
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_UNSET_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(index < segment_element_counts[selector]) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], index, 1);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_UNSET_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = ((uint32_t *) segment0)[size_index];
					if(res_start_index + res_count <= segment_element_counts[selector] && res_start_index + res_count >= res_start_index) {
						qb_shrink_segment(cxt, &cxt->storage->segments[selector], res_start_index, res_count);
					}
					
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MOV_F64_S32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (int32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (int32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_S32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint32_t *) segment0) + index;
					
					res = (uint32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + index;
					
					res = (uint32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_U32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int8_t *) segment0) + index;
					
					res = (int8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + index;
					
					res = (int8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_S08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U08_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint8_t *) segment0) + index;
					
					res = (uint8_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + index;
					
					res = (uint8_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_U08(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int16_t *) segment0) + index;
					
					res = (int16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + index;
					
					res = (int16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_S16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U16_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint16_t *) segment0) + index;
					
					res = (uint16_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U16_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + index;
					
					res = (uint16_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U16_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint16_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint16_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_U16(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int64_t *) segment0) + index;
					
					res = (int64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_S64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + index;
					
					res = (int64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_S64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_S64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((uint64_t *) segment0) + index;
					
					res = (uint64_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_U64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + index;
					
					res = (uint64_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_U64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint64_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_U64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float32_t *) segment0) + index;
					
					res = (float32_t) op1;
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_MOV_F64_F32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + index;
					
					res = (float32_t) op1;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_F64_F32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float32_t *) segments[selector]) + res_start_index;
					
					qb_do_cast_multiple_times_F64_F32(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = !(!(op1));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_BOOL_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = !(!(op1));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_BOOL_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_boolean_cast_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) fabs(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ABS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) fabs(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ABS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_abs_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIN_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (op1 < op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MIN_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (op1 < op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MIN_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_min_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (op1 > op2) ? op1 : op2;
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_MAX_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (op1 > op2) ? op1 : op2;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MAX_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_max_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) sin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) sin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = asin(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = asin(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASIN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_asin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = cos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = cos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) acos(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOS_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) acos(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_acos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = tan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TAN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = tan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_tan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = atan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATAN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = atan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_atan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATAN2_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = atan2(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_ATAN2_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = atan2(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ATAN2_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_atan2_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SINH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = sinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SINH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = sinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SINH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = asinh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ASINH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = asinh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASINH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_asinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = cosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_COSH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = cosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_COSH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = acosh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ACOSH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = acosh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ACOSH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_acosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = tanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_TANH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = tanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_TANH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_tanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = atanh(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_ATANH_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = atanh(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ATANH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_atanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = ceil(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_CEIL_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = ceil(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEIL_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_ceil_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FLOOR_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FLOOR_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_floor_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) _php_math_round(op1, op2, op3);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) _php_math_round(op1, op2, op3);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ROUND_F64_I32_I32_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((int32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((int32_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_round_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_LOG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = log(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = log(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_log_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = log1p(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG1P_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = log1p(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG1P_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_log1p_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = log2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG2_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = log2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG2_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_log2_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = log10(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_LOG10_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = log10(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LOG10_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_log10_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = exp(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = exp(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_exp_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = expm1(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXPM1_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = expm1(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXPM1_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_exp_m1_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = exp2(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_EXP2_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = exp2(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXP2_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_exp2_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_POW_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = pow(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_POW_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = pow(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_POW_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_pow_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SQRT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = sqrt(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SQRT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = sqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SQRT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sqrt_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_HYPOT_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = (float64_t) hypot(op1, op2);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_HYPOT_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = (float64_t) hypot(op1, op2);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_HYPOT_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_hypot_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LCG_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_lcg_F64(cxt, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_LCG_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_lcg_F64(cxt, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_LCG_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_lcg_multiple_times_F64(cxt, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_FIN_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = zend_finite(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FIN_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = zend_finite(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FIN_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_finite_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = (zend_isinf(op1) != 0);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_INF_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = (zend_isinf(op1) != 0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INF_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_infinite_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F64_I32_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((int32_t *) segment0) + index;
					
					res = zend_isnan(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_NAN_F64_I32_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + index;
					
					res = zend_isnan(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NAN_F64_I32_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((int32_t *) segments[selector]) + res_start_index;
					
					qb_do_is_nan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RSQRT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = qb_fast_rsqrt(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RSQRT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = qb_fast_rsqrt(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RSQRT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_rsqrt_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_clamp_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_clamp_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_CLAMP_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_clamp_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_FRACT_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 - floor(op1);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_FRACT_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 - floor(op1);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FRACT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_fract_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MIX_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 * (1 - op3) + op2 * op3;
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_MIX_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 * (1 - op3) + op2 * op3;
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MIX_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_mix_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SIGN_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_sign_F64(op1_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_SIGN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_sign_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SIGN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sign_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_STEP_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3 *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = ((op2 < op1) ? 0.0 : 1.0);
				}
				instruction_pointer += sizeof(qb_instruction_3);
				break;
				
				case QB_STEP_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = ((op2 < op1) ? 0.0 : 1.0);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_STEP_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_step_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_4 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_4 *) instruction_pointer)->operand4;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_smooth_step_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_4);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_smooth_step_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_SSTEP_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_smooth_step_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_RAD2DEG_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 * ((float64_t) (180 / M_PI));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_RAD2DEG_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 * ((float64_t) (180 / M_PI));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_RAD2DEG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_radian_to_degree_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F64_F64_VAR:
				op_handler = ((qb_instruction_2 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_2 *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					res = op1 * ((float64_t) (M_PI / 180.0));
				}
				instruction_pointer += sizeof(qb_instruction_2);
				break;
				
				case QB_DEG2RAD_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					res = op1 * ((float64_t) (M_PI / 180.0));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DEG2RAD_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_degree_to_radian_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PRN_F64_VAR:
				op_handler = ((qb_instruction_1 *) instruction_pointer)->next_handler;
				{
					float64_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1 *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					qb_do_print_variable_F64(cxt, op1_ptr);
				}
				instruction_pointer += sizeof(qb_instruction_1);
				break;
				
				case QB_PRN_F64_ELV:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_print_variable_F64(cxt, op1_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					qb_do_print_variable_multiple_times_F64(cxt, op1_ptr, op1_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_PRN_DIM_F64_U32:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					qb_do_print_multidimensional_variable_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_F64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_F64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_scalar_sprintf_length_F64(cxt, op1_ptr);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_F64(cxt, op1_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_F64_U08_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_array_sprintf_length_F64(cxt, op1_ptr, op1_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_variable_multiple_times_F64(cxt, op1_ptr, op1_count, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CAT_DIM_F64_U32_U08:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((uint32_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					string_length = qb_get_multidimensional_array_sprintf_length_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count);
					res_count = res_count + string_length;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_concat_multidimensional_variable_F64(cxt, op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PACK_LE_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F64(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_LE_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F64(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F64_U08_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F64(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_PACK_BE_F64_U08_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint8_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(8 > res_count) {
						res_count = 8;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((uint8_t *) segments[selector]) + res_start_index;
					
					qb_do_pack_F64(op1_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_LE_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					*((uint64_t *) &res) = SWAP_LE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPACK_BE_U08_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					uint8_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((uint8_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					*((uint64_t *) &res) = SWAP_BE_I64(*((uint64_t *) op1_ptr));
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_SORT_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(float64_t), qb_compare_ascending_F64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_RSORT_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qsort(res_ptr, res_count, sizeof(float64_t), qb_compare_descending_F64);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_AMIN_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_array_min_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_array_max_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_array_product_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_array_sum_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMIN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_array_min_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AMAX_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_array_max_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_APROD_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_array_product_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ASUM_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_array_sum_F64(op1_ptr, op1_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_F64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_F64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_IDX_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_array_search_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_F64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_F64(op1_ptr, op1_count, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AFIND_F64_F64_I32_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_in_array_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_APOS_F64_F64_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_ARPOS_F64_F64_I32_I32:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					int32_t *__restrict op3_ptr;
					int32_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((int32_t *) segment0) + index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4;
					res_ptr = ((int32_t *) segment0) + index;
					
					qb_do_subarray_position_from_end_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_AREV_F64_U32_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_array_reverse_F64(op1_ptr, op1_count, op2_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_AINS_F64_U32_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					res_count = res_count + op1_count;
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_array_insert_F64(op1_ptr, op1_count, op2_ptr, res_ptr, res_count, res_count_before);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_4X_F64_U32_U32_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 4 > res_count) {
						res_count = op4_count * 4;
					}
					if(op5_count * 4 > res_count) {
						res_count = op5_count * 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_NN_3X_F64_U32_U32_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 3 > res_count) {
						res_count = op4_count * 3;
					}
					if(op5_count * 3 > res_count) {
						res_count = op5_count * 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_nearest_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(4 > res_count) {
						res_count = 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_4X_F64_U32_U32_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 4 > res_count) {
						res_count = op4_count * 4;
					}
					if(op5_count * 4 > res_count) {
						res_count = op5_count * 4;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4;
					op4_ptr = ((float64_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5;
					op5_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(3 > res_count) {
						res_count = 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_F64(op1_ptr, op2_ptr, op3_ptr, op4_ptr, op5_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_SAMPLE_BL_3X_F64_U32_U32_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_6_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_6_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					uint32_t *__restrict op2_ptr;
					uint32_t *__restrict op3_ptr;
					float64_t *__restrict op4_ptr;
					float64_t *__restrict op5_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand2;
					op2_ptr = ((uint32_t *) segment0) + index;
					
					index = ((qb_instruction_6_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((uint32_t *) segment0) + index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand4 >> 20;
					op4_start_index = ((uint32_t *) segment0)[index_index];
					op4_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op4_start_index + op4_count > segment_element_counts[selector] || op4_start_index + op4_count < op4_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op4_start_index, op4_count, PHP_LINE_NUMBER);
					}
					op4_ptr = ((float64_t *) segments[selector]) + op4_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand5 >> 20;
					op5_start_index = ((uint32_t *) segment0)[index_index];
					op5_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op5_start_index + op5_count > segment_element_counts[selector] || op5_start_index + op5_count < op5_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op5_start_index, op5_count, PHP_LINE_NUMBER);
					}
					op5_ptr = ((float64_t *) segments[selector]) + op5_start_index;
					
					selector = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 & 0x00FF;
					index_index = (((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 8) & 0x03FF;
					size_index = ((qb_instruction_6_lineno *) instruction_pointer)->operand6 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op4_count * 3 > res_count) {
						res_count = op4_count * 3;
					}
					if(op5_count * 3 > res_count) {
						res_count = op5_count * 3;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_sample_bilinear_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op3_ptr, op4_ptr, op4_count, op5_ptr, op5_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_6_lineno);
				break;
				
				case QB_BLEND_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_alpha_blend_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_PREMULT_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_apply_premultiplication_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_UNPREMULT_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_remove_premultiplication_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MUL_MM_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					matrix2_count = op2_count / 16;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 16;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 16;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_determinant_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_determinant_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 16;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_dot_product_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_dot_product_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_length_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_length_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_length_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_distance_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_distance_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 4;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_4x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_FORE_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_4X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_4x_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_4X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_4x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
					res_ptr[2] = op1_ptr[2];
					res_ptr[3] = op1_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
					res_ptr[2] = op1_ptr[2] + op2_ptr[2];
					res_ptr[3] = op1_ptr[3] + op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_add_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
					res_ptr[2] = op1_ptr[2] - op2_ptr[2];
					res_ptr[3] = op1_ptr[3] - op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
					res_ptr[2] = op1_ptr[2] * op2_ptr[2];
					res_ptr[3] = op1_ptr[3] * op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
					res_ptr[2] = op1_ptr[2] / op2_ptr[2];
					res_ptr[3] = op1_ptr[3] / op2_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_4X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
					res_ptr[2] = fmod(op1_ptr[2], op2_ptr[2]);
					res_ptr[3] = fmod(op1_ptr[3], op2_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_4X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_4X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
					res_ptr[2] = - op1_ptr[2];
					res_ptr[3] = - op1_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_4X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_4x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_4X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
					++res_ptr[2];
					++res_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_4X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_4x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_4X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
					--res_ptr[2];
					--res_ptr[3];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_4X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_4x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_4X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
					res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
					res_ptr[3] = op1_ptr[3] + (op2_ptr[3] * op3_ptr[3]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_4X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_4x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					matrix2_count = op2_count / 9;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 9;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					matrix2_count = op2_count / 3;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 3;
					matrix2_count = op2_count / 9;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 3;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_determinant_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_determinant_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 9;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_dot_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_dot_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_length_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_length_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_length_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_distance_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_distance_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 3;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_3x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CROSS_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_3X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_3x_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_3X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_3x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
					res_ptr[2] = op1_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
					res_ptr[2] = op1_ptr[2] + op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_add_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
					res_ptr[2] = op1_ptr[2] - op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
					res_ptr[2] = op1_ptr[2] * op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
					res_ptr[2] = op1_ptr[2] / op2_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_3X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
					res_ptr[2] = fmod(op1_ptr[2], op2_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_3X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_3X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
					res_ptr[2] = - op1_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_3X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_3x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_3X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
					++res_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_3X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_3x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_3X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
					--res_ptr[2];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_3X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_3x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_3X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
					res_ptr[2] = op1_ptr[2] + (op2_ptr[2] * op3_ptr[2]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_3X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_3x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MM_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 4;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_MV_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					matrix2_count = op2_count / 2;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_VM_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 2;
					matrix2_count = op2_count / 4;
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * 2;
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MTRAN_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MTRAN_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MINV_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_determinant_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_determinant_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MDET_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / 4;
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_dot_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_dot_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DOT_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_VAR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_length_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_ELV:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_length_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_LEN_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_length_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_distance_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_distance_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIS_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NORM_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_2x_F64(op1_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NORM_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CROSS_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CROSS_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_cross_product_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_FORE_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFL_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_REFR_2X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_2x_F64(op1_ptr, op2_ptr, op3_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_REFR_2X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_TRAN_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_2x_F64(op1_ptr, op2_ptr, res_ptr);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_TRAN_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transform_vector_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOV_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0];
					res_ptr[1] = op1_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_MOV_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_copy_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_ADD_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + op2_ptr[0];
					res_ptr[1] = op1_ptr[1] + op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_ADD_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_add_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] - op2_ptr[0];
					res_ptr[1] = op1_ptr[1] - op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_SUB_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_subtract_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] * op2_ptr[0];
					res_ptr[1] = op1_ptr[1] * op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MUL_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] / op2_ptr[0];
					res_ptr[1] = op1_ptr[1] / op2_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_DIV_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_divide_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_2X_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = fmod(op1_ptr[0], op2_ptr[0]);
					res_ptr[1] = fmod(op1_ptr[1], op2_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_MOD_2X_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_modulo_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_NEG_2X_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = - op1_ptr[0];
					res_ptr[1] = - op1_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_NEG_2X_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_negate_2x_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_INC_2X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					++res_ptr[0];
					++res_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_INC_2X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_increment_2x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_2X_F64:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					--res_ptr[0];
					--res_ptr[1];
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_DEC_2X_F64_ARR:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_decrement_2x_multiple_times_F64(res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				case QB_MAC_2X_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					res_ptr[0] = op1_ptr[0] + (op2_ptr[0] * op3_ptr[0]);
					res_ptr[1] = op1_ptr[1] + (op2_ptr[1] * op3_ptr[1]);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MAC_2X_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand3 >> 20;
					op3_start_index = ((uint32_t *) segment0)[index_index];
					op3_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op3_start_index + op3_count > segment_element_counts[selector] || op3_start_index + op3_count < op3_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op3_start_index, op3_count, PHP_LINE_NUMBER);
					}
					op3_ptr = ((float64_t *) segments[selector]) + op3_start_index;
					
					selector = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(op3_count > res_count) {
						res_count = op3_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_accumulate_2x_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, op3_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_4_lineno);
				break;
				
				case QB_MUL_MM_F64_F64_F64:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MM_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * MATRIX2_COLS);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_matrix_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MV_F64_F64_F64:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_MV_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * 1);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (MATRIX1_ROWS * 1);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_matrix_by_vector_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_VM_F64_F64_F64:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MUL_VM_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (1 * MATRIX1_COLS);
					matrix2_count = op2_count / (MATRIX2_ROWS * MATRIX2_COLS);
					mmult_res_count = ((matrix1_count > matrix2_count) ? matrix1_count : matrix2_count) * (1 * MATRIX2_COLS);
					if(mmult_res_count > res_count) {
						res_count = mmult_res_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_multiply_vector_by_matrix_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_MTRAN_F64_F64:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MTRAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_transpose_matrix_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MINV_F64_F64:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MINV_F64_F64_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_invert_matrix_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F64_F64_VAR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_determinant_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F64_F64_ELV:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_determinant_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_MDET_F64_F64_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					matrix1_count = op1_count / (MATRIX1_ROWS * MATRIX1_COLS);
					if(matrix1_count > res_count) {
						res_count = matrix1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_determinant_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_dot_product_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_dot_product_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DOT_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_dot_product_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_LEN_F64_F64_VAR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_length_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_LEN_F64_F64_ELV:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_length_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_LEN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_length_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_VAR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3;
					res_ptr = ((float64_t *) segment0) + index;
					
					qb_do_distance_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_ELV:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8;
					index = ((uint32_t *) segment0)[index_index];
					if(UNEXPECTED(index >= segment_element_counts[selector])) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], index + 1);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], index, 1, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + index;
					
					qb_do_distance_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_DIS_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = ((op1_count > op2_count) ? op1_count : op2_count) / MATRIX1_COLS;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_distance_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_NORM_F64_F64:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_F64(op1_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_NORM_F64_F64_ARR:
				op_handler = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_2_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_normalize_multiple_times_F64(op1_ptr, op1_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_2_matrix_lineno);
				break;
				
				case QB_FORE_F64_F64_F64:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_FORE_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_face_forward_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFL_F64_F64_F64:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_F64(op1_ptr, op2_ptr, MATRIX1_ROWS, MATRIX1_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFL_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_3_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_matrix_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_reflect_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, MATRIX1_ROWS, MATRIX1_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
				}
				instruction_pointer += sizeof(qb_instruction_3_matrix_lineno);
				break;
				
				case QB_REFR_F64_F64_F64_F64:
				op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_F64(op1_ptr, op2_ptr, op3_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
				break;
				
				case QB_REFR_F64_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_4_matrix_lineno *) instruction_pointer)->line_number
#define MATRIX1_ROWS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 20)
#define MATRIX1_COLS			((((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions >> 10) & 0x03FF)
#define MATRIX2_ROWS			MATRIX1_COLS
#define MATRIX2_COLS			(((qb_instruction_4_matrix_lineno *) instruction_pointer)->matrix_dimensions & 0x03FF)
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict op3_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand3;
					op3_ptr = ((float64_t *) segment0) + index;
					
					selector = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 & 0x00FF;
					index_index = (((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 8) & 0x03FF;
					size_index = ((qb_instruction_4_matrix_lineno *) instruction_pointer)->operand4 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_refract_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, op3_ptr, MATRIX1_ROWS, MATRIX1_COLS, MATRIX2_ROWS, MATRIX2_COLS, res_ptr, res_count);
#undef PHP_LINE_NUMBER
#undef MATRIX1_ROWS
#undef MATRIX1_COLS
#undef MATRIX2_ROWS
#undef MATRIX2_COLS
				}
				instruction_pointer += sizeof(qb_instruction_4_matrix_lineno);
				break;
				
				case QB_CABS_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_abs_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CABS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_abs_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CARG_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_argument_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CARG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					vector_count = op1_count / 2;
					if(vector_count > res_count) {
						res_count = vector_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_argument_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CMUL_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_multiply_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CMUL_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_multiply_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CDIV_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_divide_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CDIV_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_divide_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CEXP_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_exp_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CEXP_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_exp_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLOG_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_log_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CLOG_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_log_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSQRT_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_square_root_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSQRT_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_square_root_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CPOW_F64_F64_F64:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_pow_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CPOW_F64_F64_F64_ARR:
				op_handler = ((qb_instruction_3_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_3_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict op2_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand2 >> 20;
					op2_start_index = ((uint32_t *) segment0)[index_index];
					op2_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op2_start_index + op2_count > segment_element_counts[selector] || op2_start_index + op2_count < op2_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op2_start_index, op2_count, PHP_LINE_NUMBER);
					}
					op2_ptr = ((float64_t *) segments[selector]) + op2_start_index;
					
					selector = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 & 0x00FF;
					index_index = (((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 8) & 0x03FF;
					size_index = ((qb_instruction_3_lineno *) instruction_pointer)->operand3 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(op2_count > res_count) {
						res_count = op2_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_pow_multiple_times_F64(op1_ptr, op1_count, op2_ptr, op2_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_3_lineno);
				break;
				
				case QB_CSIN_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sin_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSIN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sin_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOS_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cos_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOS_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cos_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTAN_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tan_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTAN_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tan_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSINH_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sinh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CSINH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_sinh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOSH_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cosh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CCOSH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_cosh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTANH_F64_F64:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tanh_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_CTANH_F64_F64_ARR:
				op_handler = ((qb_instruction_2_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_2_lineno *) instruction_pointer)->line_number
					float64_t *__restrict op1_ptr;
					float64_t *__restrict res_ptr;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand1 >> 20;
					op1_start_index = ((uint32_t *) segment0)[index_index];
					op1_count = ((uint32_t *) segment0)[size_index];
					if(UNEXPECTED(op1_start_index + op1_count > segment_element_counts[selector] || op1_start_index + op1_count < op1_start_index)) {
						qb_abort_range_error(cxt, &cxt->storage->segments[selector], op1_start_index, op1_count, PHP_LINE_NUMBER);
					}
					op1_ptr = ((float64_t *) segments[selector]) + op1_start_index;
					
					selector = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 & 0x00FF;
					index_index = (((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 8) & 0x03FF;
					size_index = ((qb_instruction_2_lineno *) instruction_pointer)->operand2 >> 20;
					res_start_index = ((uint32_t *) segment0)[index_index];
					res_count = res_count_before = ((uint32_t *) segment0)[size_index];
					if(op1_count > res_count) {
						res_count = op1_count;
					}
					if(UNEXPECTED(res_count > res_count_before || res_start_index + res_count > segment_element_counts[selector] || res_start_index + res_count < res_start_index)) {
						if(segment_expandable[selector]) {
							qb_enlarge_segment(cxt, &cxt->storage->segments[selector], res_start_index + res_count);
						} else {
							qb_abort_range_error(cxt, &cxt->storage->segments[selector], res_start_index, res_count, PHP_LINE_NUMBER);
						}
					}
					res_ptr = ((float64_t *) segments[selector]) + res_start_index;
					
					qb_do_complex_tanh_multiple_times_F64(op1_ptr, op1_count, res_ptr, res_count);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_2_lineno);
				break;
				
				case QB_EXT_U32:
				op_handler = ((qb_instruction_1_lineno *) instruction_pointer)->next_handler;
				{
#define PHP_LINE_NUMBER	((qb_instruction_1_lineno *) instruction_pointer)->line_number
					uint32_t *__restrict op1_ptr;
					
					index = ((qb_instruction_1_lineno *) instruction_pointer)->operand1;
					op1_ptr = ((uint32_t *) segment0) + index;
					
					qb_run_zend_extension_op(cxt, op1, PHP_LINE_NUMBER);
#undef PHP_LINE_NUMBER
				}
				instruction_pointer += sizeof(qb_instruction_1_lineno);
				break;
				
				default:
				__assume(0);
			}
		} while(1);
		label_exit:
		{
			uint32_t i;
			// point the stack_ref pointer back to variables in the structure
			for(i = 0; i < cxt->storage->segment_count; i++) {
				qb_memory_segment *segment = &cxt->storage->segments[i];
				segment->stack_ref_memory = &segment->memory;
				segment->stack_ref_element_count = &segment->element_count;
			}
			return;
		}
	}
	
}

#if NATIVE_COMPILE_ENABLED && ZEND_DEBUG
#include "qb_native_proc_debug.c"
#ifdef HAVE_NATIVE_PROC_RECORDS
qb_native_proc_record *native_proc_table = native_proc_records;
uint32_t native_proc_table_size = sizeof(native_proc_records) / sizeof(qb_native_proc_record);
#else
qb_native_proc_record *native_proc_table = NULL;
uint32_t native_proc_table_size = 0;
#endif
#endif
